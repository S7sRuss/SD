
Compilar para llvm:

llvm-gcc -c -09 -s -emit-llvm runtime.c
llvm-as runtime.s
llvm-as code.s
llvm-ld a.s.bc runtime.s.bc

*********							******************************************************************************************************************************
*********			CALC			******************************************************************************************************************************
*********							******************************************************************************************************************************


1
1+1
11



*********							******************************************************************************************************************************
*********			CALCI			******************************************************************************************************************************
*********							******************************************************************************************************************************

2		decl x=8 in 2 end
18		decl x=8 in x+x+2 end
7		1 + decl x=2 in x+4 end
9		decl x=2 in x+3 end + decl x=2 in x+x end
19		decl x=2 in x + decl x=5+x in x+3 end + 7 end
9		decl x=2 in x + decl y=3 in y+decl x=4 in x end end end
5		decl y=2 in decl x=2*y in decl y = 1 in x+y end end end
9		decl y=2 in decl x=2*y in decl y = 1 in x+y end + y end +y end


*********							******************************************************************************************************************************
*********			CALCF			******************************************************************************************************************************
*********							******************************************************************************************************************************

		(g)(2);

		decl g = fun x -> x+f(x) end in (g)(2) end;

		decl f= fun y -> y+x end in decl g = fun x -> x+f(x) end in (g)(2) end end;

		decl x=1 in 
			decl f = fun y -> y+x end in 
				decl g = fun x -> x+f(x) end 
					in (g)(2) 
				end
			end
		end;

		fun x -> x+1 end;

5		fun x -> x+1 end (4);

		decl x = g(2) in x+x end;

		decl g = fun y -> f(y)+2 end in
				decl x = g(2)
					in x+x end end;

10		decl f= fun x -> x+1 end in         
			decl g = fun y -> f(y)+2 end in
				decl x = g(2)
					in x+x
				end
			end
		end;

*********							******************************************************************************************************************************
*********			CALCState		******************************************************************************************************************************
*********							******************************************************************************************************************************

decl x = var(0) in
     while (not !x == 10) x := !x + 1
     ,
     !x
;



*********							******************************************************************************************************************************
*********			CALCStateT		******************************************************************************************************************************
*********							******************************************************************************************************************************



fun x:int -> x+2 end (4)


*********							******************************************************************************************************************************
*********			CALCStateT 		******************************************************************************************************************************
*********	+ Funções(em Closures)  ******************************************************************************************************************************



	decl x = 
		fun y -> decl z=0 
				 in while(z<10) y:= !y*2 end 

	in x(7) end
	;;

	decl x = 7 in x end ;;

	decl x = 7 in x-x+x*x/x end ;;

	


*********							******************************************************************************************************************************
*********			CALC~Control	******************************************************************************************************************************
*********	 						******************************************************************************************************************************

Haskell: ( Add (Sub (Num 0) (Num 1) ) (Mul (Div (Num 4) (Num 2) ) (Num 2) ) )
Ocaml: Add( Sub( Number(0),Number(1) ),Mul( Div( Number(4),Number(2) ),Number(2)))

Haskell: (Decl "x" (Num 1) (Add (Id "x" None) (Id "x" None)) None)
Ocaml: Decl("x",Number(1),Add(Id("x",None),Id("x",None)),None)


Testar a inexistência de ambiguidade nas sintaxes. Ex:

	if (false)
	then a=1
	if (false)
	then a=2
	else a=3
	else a=4

QUal será o valor de a? Pela convenção, dado que não há chavetas, o primeiro else tem de pertencer ao segundo if. Logo, o a tem de ser 4


Testar a inexistência de ambiguidade nas semânticas

	a=0;
	int f(int x){ int y=a+x; a=y; return y;  }
	b = f(4)+f(5);


Qual será o valor de b? Se o programa trabalhar lendo da direita para esquerda, então deve calcular primeito f(5) e depois f(4), 
o que daria 14

Se trabalhar da esquerda para a direita, dará 13

A convenção deve estar bem definida.



decl x = fun x:int -> x+x in x(4);;

//Avaliação deverá ser da esquerda para a direita
//Deverá devolver 13
decl a = var(0) in 
	decl f = fun x:int -> { decl y=!a+x in {a=y;y} } in
	{ f(4)+f(5) };; 
